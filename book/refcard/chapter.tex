\chapter{RV32I Reference Cards}%
\nolinenumbers%
\vspace{-1cm}
{\small%
\begin{tabular}{|ll|c|l|l|}
\hline
\multicolumn{2}{|c|}{Usage Template}	& Type	& Description	& Detailed Description \\
\hline
\hline
add   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:add]{Add}                       & {\tt rd $\leftarrow$ rs1 + rs2, pc $\leftarrow$ pc+4}\\
\hline
addi  & rd, rs1, imm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:addi]{Add Immediate}             & {\tt rd $\leftarrow$ rs1 + \hyperref[imm.i:decode]{imm\_i}, pc $\leftarrow$ pc+4}\\
\hline
and   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:and]{And}                       & {\tt rd $\leftarrow$ rs1 $\land$ rs2, pc $\leftarrow$ pc+4}\\
\hline
andi  & rd, rs1, imm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:andi]{And Immediate}             & {\tt rd $\leftarrow$ rs1 $\land$ \hyperref[imm.i:decode]{imm\_i}, pc $\leftarrow$ pc+4}\\
\hline
auipc & rd, imm        & \hyperref[insnformat:utype]{U} & \hyperref[insn:auipc]{Add Upper Immediate to PC} & {\tt rd $\leftarrow$ pc + \hyperref[imm.u:decode]{imm\_u}, pc $\leftarrow$ pc+4}\\
\hline
beq   & rs1, rs2, \hyperref[pcrel.13]{pcrel\_13} & \hyperref[insnformat:btype]{B} & \hyperref[insn:beq]{Branch Equal}               & {\tt pc $\leftarrow$ pc + (\verb@(rs1==rs2) ? @\hyperref[imm.b:decode]{imm\_b}\verb@ : 4@)}\\
\hline
bge   & rs1, rs2, \hyperref[pcrel.13]{pcrel\_13} & \hyperref[insnformat:btype]{B} & \hyperref[insn:bge]{Branch Greater or Equal}    & {\tt pc $\leftarrow$ pc + (\verb@(rs1>=rs2) ? @\hyperref[imm.b:decode]{imm\_b}\verb@ : 4@)}\\
\hline
bgeu  & rs1, rs2, \hyperref[pcrel.13]{pcrel\_13} & \hyperref[insnformat:btype]{B} & \hyperref[insn:bgeu]{Branch Greater or Equal Unsigned} & {\tt pc $\leftarrow$ pc + (\verb@(rs1>=rs2) ? @\hyperref[imm.b:decode]{imm\_b}\verb@ : 4@)}\\
\hline
blt   & rs1, rs2, \hyperref[pcrel.13]{pcrel\_13} & \hyperref[insnformat:btype]{B} & \hyperref[insn:blt]{Branch Less Than}           & {\tt pc $\leftarrow$ pc + (\verb@(rs1<rs2) ? @\hyperref[imm.b:decode]{imm\_b}\verb@ : 4@)}\\
\hline
bltu  & rs1, rs2, \hyperref[pcrel.13]{pcrel\_13} & \hyperref[insnformat:btype]{B} & \hyperref[insn:bltu]{Branch Less Than Unsigned} & {\tt pc $\leftarrow$ pc + (\verb@(rs1<rs2) ? @\hyperref[imm.b:decode]{imm\_b}\verb@ : 4@)}\\
\hline
bne   & rs1, rs2, \hyperref[pcrel.13]{pcrel\_13} & \hyperref[insnformat:btype]{B} & \hyperref[insn:bne]{Branch Not Equal}           & {\tt pc $\leftarrow$ pc + (\verb@(rs1!=rs2) ? @\hyperref[imm.b:decode]{imm\_b}\verb@ : 4@)}\\
\hline
csrrw & rd, csr, rs1  & \hyperref[insnformat:itype]{I} & \hyperref[insn:csrrw]{Atomic Read/Write} & {\tt rd $\leftarrow$ csr,  csr $\leftarrow$ rs1, pc $\leftarrow$ pc+4}\\
\hline
csrrs & rd, csr, rs1  & \hyperref[insnformat:itype]{I} & \hyperref[insn:csrrs]{Atomic Read and Set} & {\tt rd $\leftarrow$ csr,  csr $\leftarrow$ csr $\lor$ rs1, pc $\leftarrow$ pc+4}\\
\hline
csrrc & rd, csr, rs1  & \hyperref[insnformat:itype]{I} & \hyperref[insn:csrrc]{Atomic Read and Clear} & {\tt rd $\leftarrow$ csr,  csr $\leftarrow$ csr $\land$ $\sim$rs1, pc $\leftarrow$ pc+4}\\
\hline
csrrwi & rd, csr, zimm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:csrrwi]{Atomic Read/Write Immediate} & {\tt rd $\leftarrow$ csr,  csr $\leftarrow$ zimm, pc $\leftarrow$ pc+4}\\
\hline
csrrsi & rd, csr, zimm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:csrrsi]{Atomic Read and Set Immediate} & {\tt rd $\leftarrow$ csr,  csr $\leftarrow$ csr $\lor$ zimm, pc $\leftarrow$ pc+4}\\
\hline
csrrci & rd, csr, zimm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:csrrci]{Atomic Read and Clear Immediate} & {\tt rd $\leftarrow$ csr,  csr $\leftarrow$ csr $\land$ $\sim$zimm, pc $\leftarrow$ pc+4}\\
\hline
ecall & & \hyperref[insnformat:itype]{I} & \hyperref[insn:ecall]{Environment Call} & Transfer Control to Debugger \\
\hline
ebreak & & \hyperref[insnformat:itype]{I} & \hyperref[insn:ebreak]{Environment Break} & Transfer Control to Operating System \\
\hline
jal   & rd, \hyperref[pcrel.21]{pcrel\_21}     & \hyperref[insnformat:jtype]{J} & \hyperref[insn:jal]{Jump And Link}               & {\tt rd $\leftarrow$ pc+4, pc $\leftarrow$ pc+\hyperref[imm.j:decode]{imm\_j}}\\
\hline
jalr  & rd, imm(rs1) & \hyperref[insnformat:itype]{I} & \hyperref[insn:jalr]{Jump And Link Register}     & {\tt rd $\leftarrow$ pc+4, pc $\leftarrow$ (rs1+\hyperref[imm.i:decode]{imm\_i}) $\land$ $\sim$1}\\
\hline
lb    & rd, imm(rs1)  & \hyperref[insnformat:itype]{I} & \hyperref[insn:lb]{Load Byte}                   & {\tt rd $\leftarrow$ \hyperref[extension:sx]{sx}(\hyperref[memory:m8]{m8}(rs1+\hyperref[imm.i:decode]{imm\_i})), pc $\leftarrow$ pc+4}\\
\hline
lbu   & rd, imm(rs1)  & \hyperref[insnformat:itype]{I} & \hyperref[insn:lbu]{Load Byte Unsigned}         & {\tt rd $\leftarrow$ \hyperref[extension:zx]{zx}(\hyperref[memory:m8]{m8}(rs1+\hyperref[imm.i:decode]{imm\_i})), pc $\leftarrow$ pc+4}\\
\hline
lh    & rd, imm(rs1)  & \hyperref[insnformat:itype]{I} & \hyperref[insn:lh]{Load Halfword}               & {\tt rd $\leftarrow$ \hyperref[extension:sx]{sx}(\hyperref[memory:m16]{m16}(rs1+\hyperref[imm.i:decode]{imm\_i})), pc $\leftarrow$ pc+4}\\
\hline
lhu   & rd, imm(rs1)  & \hyperref[insnformat:itype]{I} & \hyperref[insn:lhu]{Load Halfword Unsigned}     & {\tt rd $\leftarrow$ \hyperref[extension:zx]{zx}(\hyperref[memory:m16]{m16}(rs1+\hyperref[imm.i:decode]{imm\_i})), pc $\leftarrow$ pc+4}\\
\hline
lui   & rd, imm        & \hyperref[insnformat:utype]{U} & \hyperref[insn:lui]{Load Upper Immediate}        & {\tt rd $\leftarrow$ \hyperref[imm.u:decode]{imm\_u}, pc $\leftarrow$ pc+4}\\
\hline
lw    & rd, imm(rs1)  & \hyperref[insnformat:itype]{I} & \hyperref[insn:lw]{Load Word}                   & {\tt rd $\leftarrow$ \hyperref[extension:sx]{sx}(\hyperref[memory:m32]{m32}(rs1+\hyperref[imm.i:decode]{imm\_i})), pc $\leftarrow$ pc+4}\\
\hline
or    & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:or]{Or}                         & {\tt rd $\leftarrow$ rs1 $\lor$ rs2, pc $\leftarrow$ pc+4}\\
\hline
ori   & rd, rs1, imm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:ori]{Or Immediate}               & {\tt rd $\leftarrow$ rs1 $\lor$ \hyperref[imm.i:decode]{imm\_i}, pc $\leftarrow$ pc+4}\\
\hline
sb    & rs2, imm(rs1) & \hyperref[insnformat:stype]{S} & \hyperref[insn:sb]{Store Byte}                  & {\tt \hyperref[memory:m8]{m8}(rs1+\hyperref[imm.s:decode]{imm\_s}) $\leftarrow$ rs2[7:0], pc $\leftarrow$ pc+4}\\
\hline
sh    & rs2, imm(rs1) & \hyperref[insnformat:stype]{S} & \hyperref[insn:sh]{Store Halfword}              & {\tt \hyperref[memory:m16]{m16}(rs1+\hyperref[imm.s:decode]{imm\_s}) $\leftarrow$ rs2[15:0], pc $\leftarrow$ pc+4}\\
\hline
sll   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:sll]{Shift Left Logical}        & {\tt rd $\leftarrow$ rs1 << (rs2\%\hyperref[XLEN]{XLEN}), pc $\leftarrow$ pc+4}\\
\hline
slli  & rd, rs1, shamt & \hyperref[insnformat:itype]{I} & \hyperref[insn:slli]{Shift Left Logical Immediate} & {\tt rd $\leftarrow$ rs1 << \hyperref[shamt.i:decode]{shamt\_i}, pc $\leftarrow$ pc+4}\\
\hline
slt   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:slt]{Set Less Than}             & {\tt rd $\leftarrow$ (rs1 < rs2) ?\ 1 :\ 0, pc $\leftarrow$ pc+4}\\
\hline
slti  & rd, rs1, imm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:slti]{Set Less Than Immediate}   & {\tt rd $\leftarrow$ (rs1 < \hyperref[imm.i:decode]{imm\_i}) ?\ 1 :\ 0, pc $\leftarrow$ pc+4}\\
\hline
sltiu & rd, rs1, imm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:sltiu]{Set Less Than Immediate Unsigned} & {\tt rd $\leftarrow$ (rs1 < \hyperref[imm.i:decode]{imm\_i}) ?\ 1 :\ 0, pc $\leftarrow$ pc+4}\\
\hline
sltu  & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:sltu]{Set Less Than Unsigned}   & {\tt rd $\leftarrow$ (rs1 < rs2) ?\ 1 :\ 0, pc $\leftarrow$ pc+4}\\
\hline
sra   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:sra]{Shift Right Arithmetic}    & {\tt rd $\leftarrow$ rs1 >> (rs2\%\hyperref[XLEN]{XLEN}), pc $\leftarrow$ pc+4}\\
\hline
srai  & rd, rs1, shamt & \hyperref[insnformat:itype]{I} & \hyperref[insn:srai]{Shift Right Arithmetic Immediate} & {\tt rd $\leftarrow$ rs1 >> \hyperref[shamt.i:decode]{shamt\_i}, pc $\leftarrow$ pc+4}\\
\hline
srl   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:srl]{Shift Right Logical}       & {\tt rd $\leftarrow$ rs1 >> (rs2\%\hyperref[XLEN]{XLEN}), pc $\leftarrow$ pc+4}\\
\hline
srli  & rd, rs1, shamt & \hyperref[insnformat:itype]{I} & \hyperref[insn:srli]{Shift Right Logical Immediate} & {\tt rd $\leftarrow$ rs1 >> \hyperref[shamt.i:decode]{shamt\_i}, pc $\leftarrow$ pc+4}\\
\hline
sub   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:sub]{Subtract}                  & {\tt rd $\leftarrow$ rs1 - rs2, pc $\leftarrow$ pc+4}\\
\hline
sw    & rs2, imm(rs1) & \hyperref[insnformat:stype]{S} & \hyperref[insn:sw]{Store Word}                  & {\tt \hyperref[memory:m32]{m32}(rs1+\hyperref[imm.s:decode]{imm\_s}) $\leftarrow$ rs2[31:0], pc $\leftarrow$ pc+4}\\
\hline
xor   & rd, rs1, rs2   & \hyperref[insnformat:rtype]{R} & \hyperref[insn:xor]{Exclusive Or}              & {\tt rd $\leftarrow$ rs1 $\oplus$ rs2, pc $\leftarrow$ pc+4}\\
\hline
xori  & rd, rs1, imm  & \hyperref[insnformat:itype]{I} & \hyperref[insn:xori]{Exclusive Or Immediate}    & {\tt rd $\leftarrow$ rs1 $\oplus$ \hyperref[imm.i:decode]{imm\_i}, pc $\leftarrow$ pc+4}\\
\hline
\end{tabular}
}%
\newpage
{\Large RV32I Base Instruction Set Encoding}~\cite[p.~104]{rvismv1v22:2017}

%\DrawAllInsnTypes
\DrawAllInsnOps
\newpage%
\thispagestyle{empty}%
%\newgeometry{left=1.3in,width=8.1in,height=13in,top=1in,bottom=0in}%
\newgeometry{left=0in,width=8in,height=10.5in,vmargin=0in,hmargin=0in,layouthoffset=1.35in,layoutvoffset=1in}%
%\resizebox{8in}{!}{\rotatebox{90}{\DrawAllInsnOps}}
%\resizebox{8in}{!}{\rotatebox{90}{\DrawGCAllInsnOps}}
\resizebox{8in}{10.7in}{\rotatebox{90}{\DrawGCAllInsnOps}}

\newpage%
\thispagestyle{empty}%
\resizebox{8in}{!}{
\rotatebox{-90}{
\DrawInsnRibbons
}
}
\restoregeometry
